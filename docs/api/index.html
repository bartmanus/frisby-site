<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="author" content="Vance Lucas"><meta name="description"><title>Frisby.js API Documentation&mdash;Frisby.js</title><link href="/favicon.png" rel="icon"><link rel="alternate" href="/atom.xml" title="config.title" type="application/atom.xml"><link rel="stylesheet" href="/stylesheets/app.css"></head><body><div class="container"><div id="page_head"><a href="/"><img src="/images/logo-frisby.png"></a></div><div class="row"><nav id="topnav" role="navigation" class="navbar navbar-default"><ul class="nav navbar-nav"><li><a href="/">Home</a></li><li><a href="/docs/api">Documentation</a></li></ul></nav></div><section id="page_content"><article><h2>Frisby.js API Documentation</h2><p>The main Frisby API methods</p>
<h3 id="Expectations">Expectations</h3>
<p>Expectation helper methods are used after the create method, and before the<br>toss method that generates the final Jasmine test spec. These helpers make<br>testing API response bodies and headers easy with minimal time and effort.</p>
<h4 id="expectStatus(_code_)">expectStatus( code )</h4>
<p>Tests that HTTP Status code equals expectation</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure we are dealing with a teapot'</span>)
  .get(<span class="string">'http://httpbin.org/status/418'</span>)
    .expectStatus(<span class="number">418</span>)
.toss()
</pre></td></tr></table></figure>

<h4 id="expectHeader(_key,_content_)">expectHeader( key, content )</h4>
<p>Tests that HTTP response contains a specific header with exact content. Both<br>key and content comparisons are case-insensitive (converted to lowercase<br>    internally). Uses Jasmine’s toEqual matcher (strict).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure response has a proper JSON Content-Type header'</span>)
  .get(<span class="string">'http://httpbin.org/get'</span>)
    .expectHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>)
.toss();
</pre></td></tr></table></figure>

<h4 id="expectHeaderContains(_key,_content_)">expectHeaderContains( key, content )</h4>
<p>Less strict version of expectHeader. Checks to ensure content exists within<br>header. Uses Jasmine’s toContain matcher internally.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure response has JSON somewhere in the Content-Type header'</span>)
  .get(<span class="string">'http://httpbin.org/get'</span>)
    .expectHeaderContains(<span class="string">'Content-Type'</span>, <span class="string">'json'</span>)
.toss();
</pre></td></tr></table></figure>

<h4 id="expectJSON(_[path],_json_)">expectJSON( [path], json )</h4>
<p>Tests that response body is JSON and contains the provided JSON keys and values<br>in the response.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure test has foo and bar'</span>)
  .get(<span class="string">'http://httpbin.org/get?foo=bar&bar=baz'</span>)
    .expectJSON({
      args: {
        foo: <span class="string">'bar'</span>,
        bar: <span class="string">'baz'</span>
      }
    })
.toss()
</pre></td></tr></table></figure>

<h4 id="expectJSONTypes(_[path],_json_)">expectJSONTypes( [path], json )</h4>
<p>Identical syntax as expectJSON, but tests the types of the JSON values instead<br>of the content.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure response has proper JSON types in specified keys'</span>)
  .post(<span class="string">'http://httpbin.org/post'</span>, {
      arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
      foo: <span class="string">"bar"</span>,
      bar: <span class="string">"baz"</span>,
      answer: <span class="number">42</span>
    })
    .expectJSONTypes(<span class="string">'args'</span>, {
      arr: <span class="built_in">Array</span>,
      foo: <span class="built_in">String</span>,
      bar: <span class="built_in">String</span>,
      answer: <span class="built_in">Number</span>
    })
.toss()
</pre></td></tr></table></figure>

<h4 id="Using_Paths_with_expectJSON_and_expectJSONTypes">Using Paths with expectJSON and expectJSONTypes</h4>
<p>In addition to nested JSON, both expectJSON and expectJSONTypes accept a path<br>as the first parameter as a useful shortcut. The path parameter can be a nested<br>path separated by periods, like ‘args.foo.mypath’, or a simple path like<br>‘results’.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure test has foo and bar'</span>)
  .get(<span class="string">'http://httpbin.org/get?foo=bar&bar=baz'</span>)
    .expectJSON(<span class="string">'args'</span>, {
      foo: <span class="string">'bar'</span>,
      bar: <span class="string">'baz'</span>
    })
.toss()
</pre></td></tr></table></figure>

<h5 id="Testing_Arrays_of_Objects">Testing Arrays of Objects</h5>
<p>In addition to accepting a nested path, both expectJSON and expectJSONContains<br>accept two special variations for testing arrays of objects. One is for testing<br>all of the objects in an array, and the other is for testing for at least one<br>object in an array.</p>
<h5 id="All_Objects_in_an_Array">All Objects in an Array</h5>
<p>To use expectJSON and expectJSONContains test all objects in an array, simply<br>append a path with an asterisk character, so the path looks like<br>args.path.myarray.<em> if the array is at the root level, just use ‘</em>‘ as the<br>path.</p>
<p>This path mode is often combined with expectJSONTypes to ensure each item in an<br>array contains all the proper keys and types required.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure each tweet has base attributes'</span>)
  .get(<span class="string">'https://api.twitter.com/1/statuses/user_timeline.json?screen_name=brightbit'</span>)
  .expectStatus(<span class="number">200</span>)
  .expectHeaderContains(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>)
  .expectJSONTypes(<span class="string">'*'</span>, {
    id_str: <span class="built_in">String</span>,
    retweeted: <span class="built_in">Boolean</span>,
    in_reply_to_screen_name: <span class="function"><span class="keyword">function</span><span class="params">(val)</span> {</span> expect(val).toBeTypeOrNull(<span class="built_in">String</span>); }, <span class="comment">// Custom matcher callback</span>
    user: {
      verified: <span class="built_in">Boolean</span>,
      location: <span class="built_in">String</span>,
      url: <span class="built_in">String</span>
    }
  })
.toss();
</pre></td></tr></table></figure>

<p>Note that a custom callback is used in this example. When a callback is used,<br> Frisby does not run any match for that key. The callback either has to<br> return true/false (pass/fail), or can use custom Jasmine matchers<br> directly. Custom callbacks are an easy way to use your own Jasmine<br> matchers or comparison methods in conjunction with Frisby.</p>
<h5 id="One_Object_in_an_Array">One Object in an Array</h5>
<p>To use expectJSON and expectJSONContains to test for one object in an array<br>that matches, simply append a path with an question mark, so the path looks<br>like args.path.myarray.? if the array is at the root level, just use ‘?’ as the<br>path.</p>
<p>This path mode is most useful when combined with expectJSON, because it is<br>often used when you know a specific item is supposed to exist in a returned<br>collection.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure Twitter has at least one list that is "NBA"'</span>)
  .get(<span class="string">'https://api.twitter.com/1/lists/all.json?screen_name=twitter'</span>)
    .expectStatus(<span class="number">200</span>)
    .expectHeader(<span class="string">'content-type'</span>, <span class="string">'application/json'</span>)
    .expectJSONTypes(<span class="string">'?'</span>, {
      name: <span class="string">"NBA"</span>,
      full_name: <span class="string">"@twitter/nba-7"</span>,
      id_str: <span class="string">"42840851"</span>,
      description: <span class="string">"All verified NBA players on Twitter"</span>,
      mode: <span class="string">"public"</span>
    })
.toss();
</pre></td></tr></table></figure>

<h4 id="expectBodyContains(_content_)">expectBodyContains( content )</h4>
<p>Test the HTTP response body for a given content string. This method does NOT<br>parse the response body as JSON, making it very useful for testing HTML, text,<br>or other content types. Uses Jasmine’s toContain matcher internally.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure this is *actually* a real teapot, not some imposter coffee pot'</span>)
  .get(<span class="string">'http://httpbin.org/status/418'</span>)
    .expectStatus(<span class="number">418</span>)
    .expectBodyContains(<span class="string">'teapot'</span>)
.toss()
</pre></td></tr></table></figure>

<h4 id="expectJSONLength(_[path],_length_)">expectJSONLength( [path], length )</h4>
<p>Tests given path or full JSON response for specified length. When used on<br>objects, the number of keys are counted. When used on other JavaScript types<br>like Arrays or Strings, the native length property is used for comparison.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Ensure "bar" really is only 3 characters... because you never know...'</span>)
  .get(<span class="string">'http://httpbin.org/get?foo=bar&bar=baz'</span>)
    .expectJSONLength(<span class="string">'args.foo'</span>, <span class="number">3</span>)
.toss()
</pre></td></tr></table></figure>

<h3 id="Inspectors">Inspectors</h3>
<p>Inspector helpers are useful for viewing details about the HTTP response when<br>the test does not pass, or has trouble for some reason. They are also useful<br>for debugging the API itself as a more user-friendly alternative to curl.</p>
<h4 id="inspectJSON()">inspectJSON()</h4>
<p>Dumps parsed JSON body in console using the node.js pretty printing utility<br>method util.inspect.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// Test</span>
frisby.create(<span class="string">'Just a quick inspection of the JSON HTTP response'</span>)
  .get(<span class="string">'http://httpbin.org/get?foo=bar&bar=baz'</span>)
    .inspectJSON()
.toss()
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="code"><pre><span class="comment">// Console output</span>
{ url: <span class="string">'http://httpbin.org/get?foo=bar&bar=baz'</span>,
  headers:
   { <span class="string">'Content-Length'</span>: <span class="string">''</span>,
     <span class="string">'X-Forwarded-Port'</span>: <span class="string">'80'</span>,
     Connection: <span class="string">'keep-alive'</span>,
     Host: <span class="string">'httpbin.org'</span>,
     Cookie: <span class="string">''</span>,
     <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span> },
  args: { foo: <span class="string">'bar'</span>, bar: <span class="string">'baz'</span> },
  origin: <span class="string">'127.0.0.1'</span> }
</pre></td></tr></table></figure>

<h4 id="inspectBody()">inspectBody()</h4>
<p>Dumps the raw response body without any parsing or markup added.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="comment">// Test</span>
frisby.create(<span class="string">'Very useful for HTML, text, or raw output'</span>)
  .get(<span class="string">'http://asciime.heroku.com/generate_ascii?s=Frisby.js'</span>)
    .inspectBody()
.toss()
</pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>// Console Output
  <span class="strong">_____</span><span class="emphasis">_    _</span>     <span class="emphasis">_             _</span>
 |  <span class="emphasis">___</span><span class="emphasis">_|  (_</span>)   | |           (_)
 | |<span class="strong">__ _ __</span> <span class="emphasis">_ _</span><span class="strong">__| |__</span>  <span class="emphasis">_   _</span>   <span class="emphasis">_ _</span>__
 |  <span class="strong">__| '__</span>| / <span class="strong">__| '_ \| | | | | / __</span>|
 | |  | |  | \<span class="strong">__ \ |_) | |_| |_| \__</span> \
 |<span class="emphasis">_|  |_</span>|  |<span class="emphasis">_|_</span><span class="strong">__/_.__</span>/ \<span class="strong">__, (_) |__</span>_/
<span class="code">                         __/ |_/ |</span>
<span class="code">                        |___/|__/</span>
</pre></td></tr></table></figure>

<h4 id="Send_Raw_JSON_or_POST_Body">Send Raw JSON or POST Body</h4>
<p>By default, Frisby sends POST and PUT requests as<br><code>application/x-www-form-urlencoded</code> parameters. If you want to send a raw<br>request body or actual JSON, use <code>{ json: true }</code> as the third argument (object<br>literal of options).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>frisby.create(<span class="string">'Post JSON string as body'</span>)
    .post(<span class="string">'http://httpbin.org/post'</span>, {
        arr: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],
        foo: <span class="string">"bar"</span>,
        bar: <span class="string">"baz"</span>,
        answer: <span class="number">42</span>
    }, {json: <span class="literal">true</span>})
    .expectHeaderContains(<span class="string">'Content-Type'</span>, <span class="string">'json'</span>)
.toss()
</pre></td></tr></table></figure>

</article></section><footer id="page_foot"><div id="region_foot"><p>Using Frisby.js in an awesome project? <a href="http://twitter.com/vlucas">Let me know</a>!</p>
<p>Frisby.js &copy; 2012-2014 <a href="http://www.vancelucas.com">Vance Lucas</a>. All rights reserved. Open source under the <a href="http://www.opensource.org/licenses/bsd-license.php">BSD license</a>.</p>
<!-- GA Tracker Code --><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-359731-28']);
_gaq.push(['_setDomainName', 'frisbyjs.com']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
</script></div></footer></div></body></html>